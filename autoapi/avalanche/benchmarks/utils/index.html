<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>avalanche.benchmarks.utils &mdash; Avalanche 0.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/mystyle.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../search/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../">
            <img src="../../../../_static/avalanche_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Avalanche API:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../evaluation/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.evaluation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../logging/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.logging</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../models/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.models</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../training/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../core/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.core</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../#package-contents">Package Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../#avalanche.__version__">__version__</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../">Avalanche</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/autoapi/avalanche/benchmarks/utils/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-avalanche.benchmarks.utils">
<span id="avalanche-benchmarks-utils"></span><h1><a class="reference internal" href="#module-avalanche.benchmarks.utils" title="avalanche.benchmarks.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils</span></code></a><a class="headerlink" href="#module-avalanche.benchmarks.utils" title="Permalink to this headline"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="avalanche_dataset/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.avalanche_dataset</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="data_loader/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.data_loader</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dataset_definitions/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.dataset_definitions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dataset_utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.dataset_utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="datasets_from_filelists/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.datasets_from_filelists</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="torchvision_wrapper/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.torchvision_wrapper</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.utils</span></code></a></li>
</ul>
</div>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this headline"></a></h2>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline"></a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="avalanche.benchmarks.utils.AvalancheDatasetType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AvalancheDatasetType</span></code></a></p></td>
<td><p>Generic enumeration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a></p></td>
<td><p>The Dataset used as the base implementation for Avalanche.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheSubset" title="avalanche.benchmarks.utils.AvalancheSubset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AvalancheSubset</span></code></a></p></td>
<td><p>A Dataset that behaves like a PyTorch <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheTensorDataset" title="avalanche.benchmarks.utils.AvalancheTensorDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AvalancheTensorDataset</span></code></a></p></td>
<td><p>A Dataset that wraps existing ndarrays, Tensors, lists... to provide</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheConcatDataset" title="avalanche.benchmarks.utils.AvalancheConcatDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AvalancheConcatDataset</span></code></a></p></td>
<td><p>A Dataset that behaves like a PyTorch</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.PathsDataset" title="avalanche.benchmarks.utils.PathsDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PathsDataset</span></code></a></p></td>
<td><p>This class extends the basic Pytorch Dataset class to handle list of paths</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.FilelistDataset" title="avalanche.benchmarks.utils.FilelistDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FilelistDataset</span></code></a></p></td>
<td><p>This class extends the basic Pytorch Dataset class to handle filelists as</p></td>
</tr>
</tbody>
</table>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline"></a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.tensor_as_list" title="avalanche.benchmarks.utils.tensor_as_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_as_list</span></code></a>(sequence) → List</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.grouped_and_ordered_indexes" title="avalanche.benchmarks.utils.grouped_and_ordered_indexes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grouped_and_ordered_indexes</span></code></a>(targets: Sequence[int], patterns_indexes: Union[None, Sequence[int]], bucket_classes: bool = True, sort_classes: bool = False, sort_indexes: bool = False) → Union[List[int], None]</p></td>
<td><p>Given the targets list of a dataset and the patterns to include, returns the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.concat_datasets_sequentially" title="avalanche.benchmarks.utils.concat_datasets_sequentially"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat_datasets_sequentially</span></code></a>(train_dataset_list: Sequence[ISupportedClassificationDataset], test_dataset_list: Sequence[ISupportedClassificationDataset]) → Tuple[AvalancheConcatDataset, AvalancheConcatDataset, List[list]]</p></td>
<td><p>Concatenates a list of datasets. This is completely different from</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.as_avalanche_dataset" title="avalanche.benchmarks.utils.as_avalanche_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_avalanche_dataset</span></code></a>(dataset: ISupportedClassificationDataset[T_co], dataset_type: AvalancheDatasetType = None) → AvalancheDataset[T_co, TTargetType]</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.as_classification_dataset" title="avalanche.benchmarks.utils.as_classification_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_classification_dataset</span></code></a>(dataset: ISupportedClassificationDataset[T_co]) → AvalancheDataset[T_co, int]</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.as_regression_dataset" title="avalanche.benchmarks.utils.as_regression_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_regression_dataset</span></code></a>(dataset: ISupportedClassificationDataset[T_co]) → AvalancheDataset[T_co, Any]</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.as_segmentation_dataset" title="avalanche.benchmarks.utils.as_segmentation_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_segmentation_dataset</span></code></a>(dataset: ISupportedClassificationDataset[T_co]) → AvalancheDataset[T_co, Any]</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.as_undefined_dataset" title="avalanche.benchmarks.utils.as_undefined_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_undefined_dataset</span></code></a>(dataset: ISupportedClassificationDataset[T_co]) → AvalancheDataset[T_co, Any]</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.train_eval_avalanche_datasets" title="avalanche.benchmarks.utils.train_eval_avalanche_datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">train_eval_avalanche_datasets</span></code></a>(train_dataset: ISupportedClassificationDataset, test_dataset: ISupportedClassificationDataset, train_transformation, eval_transformation, dataset_type=None)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.default_image_loader" title="avalanche.benchmarks.utils.default_image_loader"><code class="xref py py-obj docutils literal notranslate"><span class="pre">default_image_loader</span></code></a>(path)</p></td>
<td><p>Sets the default image loader for the Pytorch Dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.default_flist_reader" title="avalanche.benchmarks.utils.default_flist_reader"><code class="xref py py-obj docutils literal notranslate"><span class="pre">default_flist_reader</span></code></a>(flist)</p></td>
<td><p>This reader reads a filelist and return a list of paths.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.datasets_from_filelists" title="avalanche.benchmarks.utils.datasets_from_filelists"><code class="xref py py-obj docutils literal notranslate"><span class="pre">datasets_from_filelists</span></code></a></p></td>
<td><p>This module contains useful utility functions and classes to generate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.datasets_from_paths" title="avalanche.benchmarks.utils.datasets_from_paths"><code class="xref py py-obj docutils literal notranslate"><span class="pre">datasets_from_paths</span></code></a>(train_list, test_list, complete_test_set_only=False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None)</p></td>
<td><p>This utility takes, for each dataset to generate, a list of tuples each</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.common_paths_root" title="avalanche.benchmarks.utils.common_paths_root"><code class="xref py py-obj docutils literal notranslate"><span class="pre">common_paths_root</span></code></a>(exp_list)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.ImageFolder" title="avalanche.benchmarks.utils.ImageFolder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImageFolder</span></code></a>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.utils.DatasetFolder" title="avalanche.benchmarks.utils.DatasetFolder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DatasetFolder</span></code></a>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.tensor_as_list">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">tensor_as_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/utils/#tensor_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.tensor_as_list" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.grouped_and_ordered_indexes">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">grouped_and_ordered_indexes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patterns_indexes</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">None</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bucket_classes</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_classes</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_indexes</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/utils/#grouped_and_ordered_indexes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.grouped_and_ordered_indexes" title="Permalink to this definition"></a></dt>
<dd><p>Given the targets list of a dataset and the patterns to include, returns the
pattern indexes sorted according to the <code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code>,
<code class="docutils literal notranslate"><span class="pre">sort_classes</span></code> and <code class="docutils literal notranslate"><span class="pre">sort_indexes</span></code> parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>targets</strong> – The list of pattern targets, as a list.</p></li>
<li><p><strong>patterns_indexes</strong> – A list of pattern indexes to include in the set.
If None, all patterns will be included.</p></li>
<li><p><strong>bucket_classes</strong> – If True, pattern indexes will be returned so that
patterns will be grouped by class. Defaults to True.</p></li>
<li><p><strong>sort_classes</strong> – If both <code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code> and <code class="docutils literal notranslate"><span class="pre">sort_classes</span></code> are
True, class groups will be sorted by class index. Ignored if
<code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code> is False. Defaults to False.</p></li>
<li><p><strong>sort_indexes</strong> – If True, patterns indexes will be sorted. When
bucketing by class, patterns will be sorted inside their buckets.
Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of pattern indexes sorted according to the
<code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code>, <code class="docutils literal notranslate"><span class="pre">sort_classes</span></code> and <code class="docutils literal notranslate"><span class="pre">sort_indexes</span></code> parameters or
None if the patterns_indexes is None and the whole dataset can be taken
using the existing patterns order.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.SupportedDataset">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">SupportedDataset</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.SupportedDataset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDatasetType">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">AvalancheDatasetType</span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDatasetType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Generic enumeration.</p>
<p>Derive from this class to define new enumerations.</p>
<p>Create and return a new object.  See help(type) for accurate signature.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDatasetType.UNDEFINED">
<span class="sig-name descname"><span class="pre">UNDEFINED</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDatasetType.UNDEFINED" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDatasetType.CLASSIFICATION">
<span class="sig-name descname"><span class="pre">CLASSIFICATION</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDatasetType.CLASSIFICATION" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDatasetType.REGRESSION">
<span class="sig-name descname"><span class="pre">REGRESSION</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDatasetType.REGRESSION" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDatasetType.SEGMENTATION">
<span class="sig-name descname"><span class="pre">SEGMENTATION</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDatasetType.SEGMENTATION" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">AvalancheDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.SupportedDataset" title="avalanche.benchmarks.utils.SupportedDataset"><span class="pre">SupportedDataset</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">XTransform</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">YTransform</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_groups</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">XTransform</span><span class="p"><span class="pre">,</span> </span><span class="pre">YTransform</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_transform_group</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_labels</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="avalanche.benchmarks.utils.AvalancheDatasetType"><span class="pre">AvalancheDatasetType</span></a></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collate_fn</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets_adapter</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IDatasetWithTargets[T_co,</span> <span class="pre">TTargetType]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset[T_co]</span></code></p>
<p>The Dataset used as the base implementation for Avalanche.</p>
<p>Instances of this dataset are usually returned from benchmarks, but it can
also be used in a completely standalone manner. This dataset can be used
to apply transformations before returning patterns/targets, it supports
slicing and advanced indexing and it also contains useful fields as
<cite>targets</cite>, which contains the pattern labels, and <cite>targets_task_labels</cite>,
which contains the pattern task labels. The <cite>task_set</cite> field can be used to
obtain a the subset of patterns labeled with a given task label.</p>
<p>This dataset can also be used to apply several advanced operations involving
transformations. For instance, it allows the user to add and replace
transformations, freeze them so that they can’t be changed, etc.</p>
<p>This dataset also allows the user to keep distinct transformations groups.
Simply put, a transformation group is a pair of transform+target_transform
(exactly as in torchvision datasets). This dataset natively supports keeping
two transformation groups: the first, ‘train’, contains transformations
applied to training patterns. Those transformations usually involve some
kind of data augmentation. The second one is ‘eval’, that will contain
transformations applied to test patterns. Having both groups can be
useful when, for instance, in need to test on the training data (as this
process usually involves removing data augmentation operations). Switching
between transformations can be easily achieved by using the
<a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset.train" title="avalanche.benchmarks.utils.AvalancheDataset.train"><code class="xref py py-func docutils literal notranslate"><span class="pre">train()</span></code></a> and <a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset.eval" title="avalanche.benchmarks.utils.AvalancheDataset.eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> methods.</p>
<p>Moreover, arbitrary transformation groups can be added and used. For more
info see the constructor and the <a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset.with_transforms" title="avalanche.benchmarks.utils.AvalancheDataset.with_transforms"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_transforms()</span></code></a> method.</p>
<p>This dataset will try to inherit the task labels from the input
dataset. If none are available and none are given via the <cite>task_labels</cite>
parameter, each pattern will be assigned a default task label “0”.
See the constructor for more details.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">AvalancheDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The dataset to decorate. Beware that
AvalancheDataset will not overwrite transformations already
applied by this dataset.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
eval (test) transformations. This becomes useful when in need to
test on the training dataset as test transformations usually don’t
contain random augmentations. <code class="docutils literal notranslate"><span class="pre">AvalancheDataset</span></code> natively supports
the ‘train’ and ‘eval’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and
<code class="docutils literal notranslate"><span class="pre">eval()</span></code> methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘eval’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the initial transform group
to be used. Defaults to None, which means that the current group of
the input dataset will be used (if an AvalancheDataset). If the
input dataset is not an AvalancheDataset, then ‘train’ will be
used.</p></li>
<li><p><strong>task_labels</strong> – The task label of each instance. Must be a sequence
of ints, one for each instance in the dataset. Alternatively can be
a single int value, in which case that value will be used as the
task label for all the instances. Defaults to None, which means that
the dataset will try to obtain the task labels from the original
dataset. If no task labels could be found, a default task label
“0” will be applied to all instances.</p></li>
<li><p><strong>targets</strong> – The label of each pattern. Defaults to None, which
means that the targets will be retrieved from the dataset (if
possible).</p></li>
<li><p><strong>dataset_type</strong> – The type of the dataset. Defaults to None,
which means that the type will be inferred from the input dataset.
When the <cite>dataset_type</cite> is different than UNDEFINED, a
proper value for <cite>collate_fn</cite> and <cite>targets_adapter</cite> will be set.
If the <cite>dataset_type</cite> is different than UNDEFINED, then
<cite>collate_fn</cite> and <cite>targets_adapter</cite> must not be set.</p></li>
<li><p><strong>collate_fn</strong> – The function to use when slicing to merge single
patterns. In the future this function may become the function
used in the data loading process, too. If None and the
<cite>dataset_type</cite> is UNDEFINED, the constructor will check if a
<cite>collate_fn</cite> field exists in the dataset. If no such field exists,
the default collate function will be used.</p></li>
<li><p><strong>targets_adapter</strong> – A function used to convert the values of the
targets field. Defaults to None. Note: the adapter will not change
the value of the second element returned by <cite>__getitem__</cite>.
The adapter is used to adapt the values of the targets field only.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.dataset_type">
<span class="sig-name descname"><span class="pre">dataset_type</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.dataset_type" title="Permalink to this definition"></a></dt>
<dd><p>The type of this dataset (UNDEFINED, CLASSIFICATION, …).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.targets">
<span class="sig-name descname"><span class="pre">targets</span></span><em class="property"> <span class="pre">:Sequence[TTargetType]</span></em><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.targets" title="Permalink to this definition"></a></dt>
<dd><p>A sequence of values describing the label of each pattern contained in
the dataset.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.targets_task_labels">
<span class="sig-name descname"><span class="pre">targets_task_labels</span></span><em class="property"> <span class="pre">:Sequence[int]</span></em><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.targets_task_labels" title="Permalink to this definition"></a></dt>
<dd><p>A sequence of ints describing the task label of each pattern contained
in the dataset.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.tasks_pattern_indices">
<span class="sig-name descname"><span class="pre">tasks_pattern_indices</span></span><em class="property"> <span class="pre">:Dict[int,</span> <span class="pre">Sequence[int]]</span></em><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.tasks_pattern_indices" title="Permalink to this definition"></a></dt>
<dd><p>A dictionary mapping task labels to the indices of the patterns with
that task label. If you need to obtain the subset of patterns labeled
with a certain task label, consider using the <cite>task_set</cite> field.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.collate_fn">
<span class="sig-name descname"><span class="pre">collate_fn</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.collate_fn" title="Permalink to this definition"></a></dt>
<dd><p>The collate function to use when creating mini-batches from this
dataset.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.task_set">
<span class="sig-name descname"><span class="pre">task_set</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.task_set" title="Permalink to this definition"></a></dt>
<dd><p>A dictionary that can be used to obtain the subset of patterns given
a specific task label.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.current_transform_group">
<span class="sig-name descname"><span class="pre">current_transform_group</span></span><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.current_transform_group" title="Permalink to this definition"></a></dt>
<dd><p>The name of the transform group currently in use.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.transform_groups">
<span class="sig-name descname"><span class="pre">transform_groups</span></span><em class="property"> <span class="pre">:Dict[str,</span> <span class="pre">Tuple[XTransform,</span> <span class="pre">YTransform]]</span></em><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.transform_groups" title="Permalink to this definition"></a></dt>
<dd><p>A dictionary containing the transform groups. Transform groups are
used to quickly switch between training and test (eval) transformations.
This becomes useful when in need to test on the training dataset as test
transformations usually don’t contain random augmentations.</p>
<p>AvalancheDataset natively supports switching between the ‘train’ and
‘eval’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> methods. When
using custom groups one can use the <code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code>
method instead.</p>
<p>May be null, which means that the current transforms will be used to
handle both ‘train’ and ‘eval’ groups.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><em class="property"> <span class="pre">:XTransform</span></em><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.transform" title="Permalink to this definition"></a></dt>
<dd><p>A function/transform that takes in an PIL image and returns a
transformed version.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.target_transform">
<span class="sig-name descname"><span class="pre">target_transform</span></span><em class="property"> <span class="pre">:YTransform</span></em><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.target_transform" title="Permalink to this definition"></a></dt>
<dd><p>A function/transform that takes in the target and transforms it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">'AvalancheDataset'</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.__add__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.__add__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">'AvalancheDataset'</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.__radd__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.__getitem__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.__len__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.__len__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.train" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with the transformations of the ‘train’ group
loaded.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the training transformations loaded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.eval">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.eval" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with the transformations of the ‘eval’ group
loaded.</p>
<p>Eval transformations usually don’t contain augmentation procedures.
This function may be useful when in need to test on training data
(for instance, in order to run a validation pass).</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the eval transformations loaded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.freeze_transforms">
<span class="sig-name descname"><span class="pre">freeze_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.freeze_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.freeze_transforms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset where the current transformations are frozen.</p>
<p>Frozen transformations will be permanently glued to the original
dataset so that they can’t be changed anymore. This is usually done
when using transformations to create derived datasets: in this way
freezing the transformations will ensure that the user won’t be able
to inadvertently change them by directly setting the transformations
field or by using the other transformations utility methods like
<code class="docutils literal notranslate"><span class="pre">replace_transforms</span></code>. Please note that transformations of all groups
will be frozen. If you want to freeze a specific group, please use
<code class="docutils literal notranslate"><span class="pre">freeze_group_transforms</span></code>.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the current transformations frozen.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.freeze_group_transforms">
<span class="sig-name descname"><span class="pre">freeze_group_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.freeze_group_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.freeze_group_transforms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset where the transformations for a specific group
are frozen.</p>
<p>Frozen transformations will be permanently glued to the original
dataset so that they can’t be changed anymore. This is usually done
when using transformations to create derived datasets: in this way
freezing the transformations will ensure that the user won’t be able
to inadvertently change them by directly setting the transformations
field or by using the other transformations utility methods like
<code class="docutils literal notranslate"><span class="pre">replace_transforms</span></code>. To freeze transformations of all groups
please use <code class="docutils literal notranslate"><span class="pre">freeze_transforms</span></code>.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the transformations frozen for the given
group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.get_transforms">
<span class="sig-name descname"><span class="pre">get_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transforms_group</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.get_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.get_transforms" title="Permalink to this definition"></a></dt>
<dd><p>Returns the transformations given a group.</p>
<p>Beware that this will not return the frozen transformations, nor the
ones included in the wrapped dataset. Only transformations directly
attached to this dataset will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transforms_group</strong> – The transformations group. Defaults to None,
which means that the current group is returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The transformation group, as a tuple
(transform, target_transform).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.add_transforms">
<span class="sig-name descname"><span class="pre">add_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.add_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.add_transforms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with the given transformations added to
the existing ones.</p>
<p>The transformations will be added to the current transformations group.
Other transformation groups will not be affected.</p>
<p>The given transformations will be added “at the end” of previous
transformations of the current transformations group. This means
that existing transformations will be applied to the patterns first.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the added transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.add_transforms_to_group">
<span class="sig-name descname"><span class="pre">add_transforms_to_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.add_transforms_to_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.add_transforms_to_group" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with the given transformations added to
the existing ones for a certain group.</p>
<p>The transformations will be added to the given transformations group.
Other transformation groups will not be affected. The group must
already exist.</p>
<p>The given transformations will be added “at the end” of previous
transformations of that group. This means that existing transformations
will be applied to the patterns first.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group_name</strong> – The name of the group.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the added transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.replace_transforms">
<span class="sig-name descname"><span class="pre">replace_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">XTransform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">YTransform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.replace_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.replace_transforms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with the existing transformations replaced with
the given ones.</p>
<p>The given transformations will replace the ones of the current
transformations group. Other transformation groups will not be affected.</p>
<p>If the original dataset is an instance of <a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a>,
then transformations of the original set will be considered as well
(the original dataset will be left untouched).</p>
<p>The current dataset will not be affected.</p>
<p>Note that this function will not override frozen transformations. This
will also not affect transformations found in datasets that are not
instances of <a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>group</strong> – The transforms group to replace. Defaults to None, which
means that the current group will be replaced.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the new transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.with_transforms">
<span class="sig-name descname"><span class="pre">with_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.with_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.with_transforms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with the transformations of a different group
loaded.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>group_name</strong> – The name of the transformations group to use.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the new transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheDataset.add_transforms_group">
<span class="sig-name descname"><span class="pre">add_transforms_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TAvalancheDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">XTransform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">YTransform</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TAvalancheDataset</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheDataset.add_transforms_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheDataset.add_transforms_group" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new dataset with a new transformations group.</p>
<p>The current dataset will not be affected.</p>
<p>This method raises an exception if a group with the same name already
exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group_name</strong> – The name of the new transformations group.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the new transformations.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheSubset">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">AvalancheSubset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.SupportedDataset" title="avalanche.benchmarks.utils.SupportedDataset"><span class="pre">SupportedDataset</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_mapping</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_groups</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">XTransform</span><span class="p"><span class="pre">,</span> </span><span class="pre">YTransform</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_transform_group</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_labels</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="avalanche.benchmarks.utils.AvalancheDatasetType"><span class="pre">AvalancheDatasetType</span></a></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collate_fn</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets_adapter</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheSubset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheSubset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset[T_co,</span> <span class="pre">TTargetType]</span></code></p>
<p>A Dataset that behaves like a PyTorch <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>.
This Dataset also supports transformations, slicing, advanced indexing,
the targets field, class mapping and all the other goodies listed in
<a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a>.</p>
<p>Creates an <code class="docutils literal notranslate"><span class="pre">AvalancheSubset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The whole dataset.</p></li>
<li><p><strong>indices</strong> – Indices in the whole set selected for subset. Can
be None, which means that the whole dataset will be returned.</p></li>
<li><p><strong>class_mapping</strong> – A list that, for each possible target (Y) value,
contains its corresponding remapped value. Can be None.
Beware that setting this parameter will force the final
dataset type to be CLASSIFICATION or UNDEFINED.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
eval (test) transformations. This becomes useful when in need to
test on the training dataset as test transformations usually don’t
contain random augmentations. <code class="docutils literal notranslate"><span class="pre">AvalancheDataset</span></code> natively supports
the ‘train’ and ‘eval’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and
<code class="docutils literal notranslate"><span class="pre">eval()</span></code> methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘eval’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the initial transform group
to be used. Defaults to None, which means that the current group of
the input dataset will be used (if an AvalancheDataset). If the
input dataset is not an AvalancheDataset, then ‘train’ will be
used.</p></li>
<li><p><strong>task_labels</strong> – The task label for each instance. Must be a sequence
of ints, one for each instance in the dataset. This can either be a
list of task labels for the original dataset or the list of task
labels for the instances of the subset (an automatic detection will
be made). In the unfortunate case in which the original dataset and
the subset contain the same amount of instances, then this parameter
is considered to contain the task labels of the subset.
Alternatively can be a single int value, in which case
that value will be used as the task label for all the instances.
Defaults to None, which means that the dataset will try to
obtain the task labels from the original dataset. If no task labels
could be found, a default task label “0” will be applied to all
instances.</p></li>
<li><p><strong>targets</strong> – The label of each pattern. Defaults to None, which
means that the targets will be retrieved from the dataset (if
possible). This can either be a list of target labels for the
original dataset or the list of target labels for the instances of
the subset (an automatic detection will be made). In the unfortunate
case in which the original dataset and the subset contain the same
amount of instances, then this parameter is considered to contain
the target labels of the subset.</p></li>
<li><p><strong>dataset_type</strong> – The type of the dataset. Defaults to None,
which means that the type will be inferred from the input dataset.
When the <cite>dataset_type</cite> is different than UNDEFINED, a
proper value for <cite>collate_fn</cite> and <cite>targets_adapter</cite> will be set.
If the <cite>dataset_type</cite> is different than UNDEFINED, then
<cite>collate_fn</cite> and <cite>targets_adapter</cite> must not be set.
The only exception to this rule regards <cite>class_mapping</cite>.
If <cite>class_mapping</cite> is set, the final dataset_type
(as set by this parameter or detected from the subset) must be
CLASSIFICATION or UNDEFINED.</p></li>
<li><p><strong>collate_fn</strong> – The function to use when slicing to merge single
patterns. In the future this function may become the function
used in the data loading process, too. If None and the
<cite>dataset_type</cite> is UNDEFINED, the constructor will check if a
<cite>collate_fn</cite> field exists in the dataset. If no such field exists,
the default collate function will be used.</p></li>
<li><p><strong>targets_adapter</strong> – A function used to convert the values of the
targets field. Defaults to None. Note: the adapter will not change
the value of the second element returned by <cite>__getitem__</cite>.
The adapter is used to adapt the values of the targets field only.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheTensorDataset">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">AvalancheTensorDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dataset_tensors</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_groups</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">XTransform</span><span class="p"><span class="pre">,</span> </span><span class="pre">YTransform</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_transform_group</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'train'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_labels</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="avalanche.benchmarks.utils.AvalancheDatasetType"><span class="pre">AvalancheDatasetType</span></a></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">AvalancheDatasetType.UNDEFINED</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collate_fn</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets_adapter</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheTensorDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheTensorDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset[T_co,</span> <span class="pre">TTargetType]</span></code></p>
<p>A Dataset that wraps existing ndarrays, Tensors, lists… to provide
basic Dataset functionalities. Very similar to TensorDataset from PyTorch,
this Dataset also supports transformations, slicing, advanced indexing,
the targets field and all the other goodies listed in
<a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a>.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">AvalancheTensorDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset_tensors</strong> – Sequences, Tensors or ndarrays representing the
content of the dataset.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes in a single element
from the first tensor and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes a single
element of the second tensor and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
eval (test) transformations. This becomes useful when in need to
test on the training dataset as test transformations usually don’t
contain random augmentations. <code class="docutils literal notranslate"><span class="pre">AvalancheDataset</span></code> natively supports
the ‘train’ and ‘eval’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and
<code class="docutils literal notranslate"><span class="pre">eval()</span></code> methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘eval’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the transform group
to be used. Defaults to ‘train’.</p></li>
<li><p><strong>task_labels</strong> – The task labels for each pattern. Must be a sequence
of ints, one for each pattern in the dataset. Alternatively can be a
single int value, in which case that value will be used as the task
label for all the instances. Defaults to None, which means that a
default task label “0” will be applied to all patterns.</p></li>
<li><p><strong>targets</strong> – The label of each pattern. Defaults to None, which
means that the targets will be retrieved from the dataset.
Otherwise, can be 1) a sequence of values containing as many
elements as the number of patterns, or 2) the index of the sequence
to use as the targets field. When using the default value of None,
the targets field will be populated using the second
tensor. If dataset is made of only one tensor, then that tensor will
be used for the targets field, too.</p></li>
<li><p><strong>dataset_type</strong> – The type of the dataset. Defaults to UNDEFINED.
Setting this parameter will automatically set a proper value for
<cite>collate_fn</cite> and <cite>targets_adapter</cite>. If this parameter is set to a
value different from UNDEFINED then <cite>collate_fn</cite> and
<cite>targets_adapter</cite> must not be set.</p></li>
<li><p><strong>collate_fn</strong> – The function to use when slicing to merge single
patterns. In the future this function may become the function
used in the data loading process, too.</p></li>
<li><p><strong>targets_adapter</strong> – A function used to convert the values of the
targets field. Defaults to None. Note: the adapter will not change
the value of the second element returned by <cite>__getitem__</cite>.
The adapter is used to adapt the values of the targets field only.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheConcatDataset">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">AvalancheConcatDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datasets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Collection</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#avalanche.benchmarks.utils.SupportedDataset" title="avalanche.benchmarks.utils.SupportedDataset"><span class="pre">SupportedDataset</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_groups</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">XTransform</span><span class="p"><span class="pre">,</span> </span><span class="pre">YTransform</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_transform_group</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_labels</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="avalanche.benchmarks.utils.AvalancheDatasetType"><span class="pre">AvalancheDatasetType</span></a></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collate_fn</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets_adapter</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheConcatDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheConcatDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset[T_co,</span> <span class="pre">TTargetType]</span></code></p>
<p>A Dataset that behaves like a PyTorch
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.ConcatDataset</span></code>. However, this Dataset also supports
transformations, slicing, advanced indexing and the targets field and all
the other goodies listed in <a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a>.</p>
<p>This dataset guarantees that the operations involving the transformations
and transformations groups are consistent across the concatenated dataset
(if they are subclasses of <a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">AvalancheDataset</span></code></a>).</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">AvalancheConcatDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>datasets</strong> – A collection of datasets.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
eval (test) transformations. This becomes useful when in need to
test on the training dataset as test transformations usually don’t
contain random augmentations. <code class="docutils literal notranslate"><span class="pre">AvalancheDataset</span></code> natively supports
the ‘train’ and ‘eval’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and
<code class="docutils literal notranslate"><span class="pre">eval()</span></code> methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘eval’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the initial transform group
to be used. Defaults to None, which means that if all
AvalancheDatasets in the input datasets list agree on a common
group (the “current group” is the same for all datasets), then that
group will be used as the initial one. If the list of input datasets
does not contain an AvalancheDataset or if the AvalancheDatasets
do not agree on a common group, then ‘train’ will be used.</p></li>
<li><p><strong>targets</strong> – The label of each pattern. Can either be a sequence of
labels or, alternatively, a sequence containing sequences of labels
(one for each dataset to be concatenated). Defaults to None, which
means that the targets will be retrieved from the datasets (if
possible).</p></li>
<li><p><strong>task_labels</strong> – The task labels for each pattern. Must be a sequence
of ints, one for each pattern in the dataset. Alternatively, task
labels can be expressed as a sequence containing sequences of ints
(one for each dataset to be concatenated) or even a single int,
in which case that value will be used as the task label for all
instances. Defaults to None, which means that the dataset will try
to obtain the task labels from the original datasets. If no task
labels could be found for a dataset, a default task label “0” will
be applied to all patterns of that dataset.</p></li>
<li><p><strong>dataset_type</strong> – The type of the dataset. Defaults to None,
which means that the type will be inferred from the list of
input datasets. When <cite>dataset_type</cite> is None and the list of datasets
contains incompatible types, an error will be raised.
A list of datasets is compatible if they all have
the same type. Datasets that are not instances of <cite>AvalancheDataset</cite>
and instances of <cite>AvalancheDataset</cite> with type <cite>UNDEFINED</cite>
are always compatible with other types.
When the <cite>dataset_type</cite> is different than UNDEFINED, a
proper value for <cite>collate_fn</cite> and <cite>targets_adapter</cite> will be set.
If the <cite>dataset_type</cite> is different than UNDEFINED, then
<cite>collate_fn</cite> and <cite>targets_adapter</cite> must not be set.</p></li>
<li><p><strong>collate_fn</strong> – The function to use when slicing to merge single
patterns. In the future this function may become the function
used in the data loading process, too. If None, the constructor
will check if a <cite>collate_fn</cite> field exists in the first dataset. If
no such field exists, the default collate function will be used.
Beware that the chosen collate function will be applied to all
the concatenated datasets even if a different collate is defined
in different datasets.</p></li>
<li><p><strong>targets_adapter</strong> – A function used to convert the values of the
targets field. Defaults to None. Note: the adapter will not change
the value of the second element returned by <cite>__getitem__</cite>.
The adapter is used to adapt the values of the targets field only.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.AvalancheConcatDataset.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#AvalancheConcatDataset.__len__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.AvalancheConcatDataset.__len__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.concat_datasets_sequentially">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">concat_datasets_sequentially</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_dataset_list</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_dataset_list</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheConcatDataset" title="avalanche.benchmarks.utils.AvalancheConcatDataset"><span class="pre">AvalancheConcatDataset</span></a><span class="p"><span class="pre">,</span> </span><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheConcatDataset" title="avalanche.benchmarks.utils.AvalancheConcatDataset"><span class="pre">AvalancheConcatDataset</span></a><span class="p"><span class="pre">,</span> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#concat_datasets_sequentially"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.concat_datasets_sequentially" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates a list of datasets. This is completely different from
<code class="xref py py-class docutils literal notranslate"><span class="pre">ConcatDataset</span></code>, in which datasets are merged together without
other processing. Instead, this function re-maps the datasets class IDs.
For instance:
let the dataset[0] contain patterns of 3 different classes,
let the dataset[1] contain patterns of 2 different classes, then class IDs
will be mapped as follows:</p>
<p>dataset[0] class “0” -&gt; new class ID is “0”</p>
<p>dataset[0] class “1” -&gt; new class ID is “1”</p>
<p>dataset[0] class “2” -&gt; new class ID is “2”</p>
<p>dataset[1] class “0” -&gt; new class ID is “3”</p>
<p>dataset[1] class “1” -&gt; new class ID is “4”</p>
<p>… -&gt; …</p>
<p>dataset[-1] class “C-1” -&gt; new class ID is “overall_n_classes-1”</p>
<p>In contrast, using PyTorch ConcatDataset:</p>
<p>dataset[0] class “0” -&gt; ID is “0”</p>
<p>dataset[0] class “1” -&gt; ID is “1”</p>
<p>dataset[0] class “2” -&gt; ID is “2”</p>
<p>dataset[1] class “0” -&gt; ID is “0”</p>
<p>dataset[1] class “1” -&gt; ID is “1”</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> and <code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code> must have the same
number of datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A concatenated dataset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.as_avalanche_dataset">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">as_avalanche_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDatasetType" title="avalanche.benchmarks.utils.AvalancheDatasetType"><span class="pre">AvalancheDatasetType</span></a></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><span class="pre">AvalancheDataset</span></a><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">,</span> </span><span class="pre">TTargetType</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#as_avalanche_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.as_avalanche_dataset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.as_classification_dataset">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">as_classification_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><span class="pre">AvalancheDataset</span></a><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#as_classification_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.as_classification_dataset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.as_regression_dataset">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">as_regression_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><span class="pre">AvalancheDataset</span></a><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#as_regression_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.as_regression_dataset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.as_segmentation_dataset">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">as_segmentation_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><span class="pre">AvalancheDataset</span></a><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#as_segmentation_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.as_segmentation_dataset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.as_undefined_dataset">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">as_undefined_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#avalanche.benchmarks.utils.AvalancheDataset" title="avalanche.benchmarks.utils.AvalancheDataset"><span class="pre">AvalancheDataset</span></a><span class="p"><span class="pre">[</span></span><span class="pre">T_co</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#as_undefined_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.as_undefined_dataset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.train_eval_avalanche_datasets">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">train_eval_avalanche_datasets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_dataset</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">ISupportedClassificationDataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_transformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval_transformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/avalanche_dataset/#train_eval_avalanche_datasets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.train_eval_avalanche_datasets" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.default_image_loader">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">default_image_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#default_image_loader"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.default_image_loader" title="Permalink to this definition"></a></dt>
<dd><p>Sets the default image loader for the Pytorch Dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – relative or absolute path of the file to load.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns the image as a RGB PIL image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.default_flist_reader">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">default_flist_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#default_flist_reader"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.default_flist_reader" title="Permalink to this definition"></a></dt>
<dd><p>This reader reads a filelist and return a list of paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flist</strong> – path of the flislist to read. The flist format should be:
impath label, impath label,  …(same to caffe’s filelist)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns a list of paths (the examples to be loaded).</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.PathsDataset">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">PathsDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">default_image_loader</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#PathsDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.PathsDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code></p>
<p>This class extends the basic Pytorch Dataset class to handle list of paths
as the main data source.</p>
<p>Creates a File Dataset from a list of files and labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – root path where the data to load are stored. May be None.</p></li>
<li><p><strong>files</strong> – list of tuples. Each tuple must contain two elements: the
full path to the pattern and its class label. Optionally, the tuple
may contain a third element describing the bounding box to use for
cropping (top, left, height, width).</p></li>
<li><p><strong>transform</strong> – eventual transformation to add to the input data (x)</p></li>
<li><p><strong>target_transform</strong> – eventual transformation to add to the targets
(y)</p></li>
<li><p><strong>loader</strong> – loader function to use (for the real data) given path.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.PathsDataset.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#PathsDataset.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.PathsDataset.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>Returns next element in the dataset given the current index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> – index of the data to get.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>loaded item.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.PathsDataset.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#PathsDataset.__len__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.PathsDataset.__len__" title="Permalink to this definition"></a></dt>
<dd><p>Returns the total number of elements in the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Total number of dataset items.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.FilelistDataset">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">FilelistDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flist_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">default_flist_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">default_image_loader</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#FilelistDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.FilelistDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="datasets_from_filelists/#avalanche.benchmarks.utils.datasets_from_filelists.PathsDataset" title="avalanche.benchmarks.utils.datasets_from_filelists.PathsDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils.datasets_from_filelists.PathsDataset</span></code></a></p>
<p>This class extends the basic Pytorch Dataset class to handle filelists as
main data source.</p>
<blockquote>
<div><p>This reader reads a filelist and return a list of paths.</p>
<dl class="field-list simple">
<dt class="field-odd">param root</dt>
<dd class="field-odd"><p>root path where the data to load are stored. May be None.</p>
</dd>
<dt class="field-even">param flist</dt>
<dd class="field-even"><p>path of the flislist to read. The flist format should be:
impath label</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>impath label</dt><dd><dl class="simple">
<dt>…(same to caffe’s filelist).</dt><dd><dl class="field-list simple">
<dt class="field-odd">param transform</dt>
<dd class="field-odd"><p>eventual transformation to add to the input data (x).</p>
</dd>
<dt class="field-even">param target_transform</dt>
<dd class="field-even"><p>eventual transformation to add to the targets
(y).</p>
</dd>
<dt class="field-odd">param flist_reader</dt>
<dd class="field-odd"><p>loader function to use (for the filelists) given
path.</p>
</dd>
<dt class="field-even">param loader</dt>
<dd class="field-even"><p>loader function to use (for the real data) given path.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.datasets_from_filelists">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">datasets_from_filelists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_filelists</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_filelists</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_test_set_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_target_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_target_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#datasets_from_filelists"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.datasets_from_filelists" title="Permalink to this definition"></a></dt>
<dd><p>This reader reads a list of Caffe-style filelists and returns the proper
Dataset objects.</p>
<p>A Caffe-style list is just a text file where, for each line, two elements
are described: the path to the pattern (relative to the root parameter)
and its class label. Those two elements are separated by a single white
space.</p>
<p>This method reads each file list and returns a separate
dataset for each of them.</p>
<p>Beware that the parameters must be <strong>list of paths to Caffe-style
filelists</strong>. If you need to create a dataset given a list of
<strong>pattern paths</strong>, use <cite>datasets_from_paths</cite> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – root path where the data to load are stored. May be None.</p></li>
<li><p><strong>train_filelists</strong> – list of paths to train filelists. The flist format
should be: impath labelnimpath labeln …(same to Caffe’s filelist).</p></li>
<li><p><strong>test_filelists</strong> – list of paths to test filelists. It can be also a
single path when the datasets is the same for each batch.</p></li>
<li><p><strong>complete_test_set_only</strong> – if True, test_filelists must contain
the path to a single filelist that will serve as the complete test set.
Alternatively, test_filelists can be the path (str) to the complete test
set filelist. If False, train_filelists and test_filelists must contain
the same amount of filelists paths. Defaults to False.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to training patterns.
Defaults to None.</p></li>
<li><p><strong>train_target_transform</strong> – The transformation to apply to training
patterns targets. Defaults to None.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to test patterns.
Defaults to None.</p></li>
<li><p><strong>test_target_transform</strong> – The transformation to apply to test
patterns targets. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of tuples (train dataset, test dataset) for each train
filelist in the list.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.datasets_from_paths">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">datasets_from_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_test_set_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_target_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_target_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#datasets_from_paths"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.datasets_from_paths" title="Permalink to this definition"></a></dt>
<dd><p>This utility takes, for each dataset to generate, a list of tuples each
containing two elements: the full path to the pattern and its class label.
Optionally, the tuple may contain a third element describing the bounding
box to use for cropping.</p>
<p>This is equivalent to <cite>datasets_from_filelists</cite>, which description
contains more details on the behaviour of this utility. The two utilities
differ in which <cite>datasets_from_filelists</cite> accepts paths to Caffe-style
filelists while this one is able to create the datasets from an in-memory
list.</p>
<p>Note: this utility may try to detect (and strip) the common root path of
all patterns in order to save some RAM memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_list</strong> – list of lists. Each list must contain tuples of two
elements: the full path to the pattern and its class label. Optionally,
the tuple may contain a third element describing the bounding box to use
for cropping (top, left, height, width).</p></li>
<li><p><strong>test_list</strong> – list of lists. Each list must contain tuples of two
elements: the full path to the pattern and its class label. Optionally,
the tuple may contain a third element describing the bounding box to use
for cropping (top, left, height, width). It can be also a single list
when the test dataset is the same for each experience.</p></li>
<li><p><strong>complete_test_set_only</strong> – if True, test_list must contain a single list
that will serve as the complete test set. If False, train_list and
test_list must describe the same amount of datasets. Defaults to False.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to training patterns.
Defaults to None.</p></li>
<li><p><strong>train_target_transform</strong> – The transformation to apply to training
patterns targets. Defaults to None.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to test patterns.
Defaults to None.</p></li>
<li><p><strong>test_target_transform</strong> – The transformation to apply to test
patterns targets. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tuples (train dataset, test dataset).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.common_paths_root">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">common_paths_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exp_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/datasets_from_filelists/#common_paths_root"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.common_paths_root" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.ImageFolder">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">ImageFolder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/torchvision_wrapper/#ImageFolder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.ImageFolder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="avalanche.benchmarks.utils.DatasetFolder">
<span class="sig-prename descclassname"><span class="pre">avalanche.benchmarks.utils.</span></span><span class="sig-name descname"><span class="pre">DatasetFolder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/utils/torchvision_wrapper/#DatasetFolder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#avalanche.benchmarks.utils.DatasetFolder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, ContinualAI.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>